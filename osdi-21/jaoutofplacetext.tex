\section{Somewhere else}
We are the first to quantify the impact of using library OS software on energy.  We find that as expected the library OS uses fewer instruction to complete the work and that this has impact on the energy consumed.  This largely translates into getting more application level work done in fewer instruction and this matters despite the heavy IO nature of the workloads.  This is in part due to the nature of high speed networking.  High speed data center networks put OS device and protocol processing code on the hot path -- in some sense making the workload actually more compute bound that one might expect.  Using fewer instructions (and attendant drop in busy cycles) to complete the application work leads to two energy consumption benefits; 1) it reduces the base energy cost to complete the work, and 2) it creates greater opportunities to halt the processor between network transactions.  The later benefit makes it possible to achieve a simple "race to halt" behaviour across epochs of network activity.  
Simplistically, by rapidly and efficiently finishing the work required for a network request and sending the reply, one has the opportunity to halt the processor and enter a software specified hardware sleep state\footnote{Processors typically support a range of sleep states where deeper sleep states result in less energy consumption but have higher latency and potential performance penalties when waking up.} till the next interrupt.  The actually, period that one can sleep for depends, as expected, on the workload and the optimization criteria being imposed (eg. latency versus throughput).   

We also find that across all our workloads, the simplified and naive policies of the library OS, afforded by not needing to run or arbitrate multiple applications, leads to exploiting deeper sleep states while also achieving higher performance.  In EbbRT, when an interrupt occurs, like other library OS it implements a default run to completion model, by disabling interrupts.  When there are no work,  pending interrupts or packets dequeued from prior interrupts to process, EbbRT simply halts the processor to the deepest available sleep state. In contrast, even though we disable Linux's mechanisms for setting the parameters there are other complex algorithms and policies that affect its behaviour.  For example Linux application processing runs with interrupts enabled, it implements a complex algorithm for enacting a hybrid polling versus interrupt processing across network devices and has a subtle infrastructure for deciding what sleep state should be used for halting the processor based on estimation of when the next interrupt will occur from any source.  This all contributes to a complex dynamic behavior with respect to when the system should halt and if it does halt what sleep state will be requested.  We observer that even after we use fixed values for the three  hardware setting considered the other complex behaviours of Linux limits the ability to tune its combined energy and performance compared to EbbRT.


We identify three hardware settings 

The components of cloud services such as cache servers, javascript webservers, and in-memory data bases, are  by their nature are network driven.  induce vary degrees of cpu work.  Their operation and thus their efficiency is a complex mixture of the behaviour of the system software and the application software.  While Network Interface Cards (NICs) have many adjustable parameters, Interrupt Delay, the amount of time the NIC will wait before signaling the OS device driver is an value that can easily be changed without any modification to the OS including the device driver.   As expected for a fixed workload this parameter can critically can influence the behaviour of the software for a given workload.  Delaying the packets, depending on the workload the behaviour of the software, one can vary the degree of batching of packets at the expense of increasing the latency of beginning processing a packet. Intuitively, it is possible for a particular workload and software stack their maybe a fixed value that not only optimizes performance but affects the energy consumed as the tradeoff between the frequency of waking up and the amount of work to process on every wakeup can directly influence the efficiency of providing service.  

 While library Operating systems are one way of catering to a single dedicated application it maybe possible to integrate such support into a general purpose os by adding a new "single app" kernel configuration that disables or sheds run-time complexity and dynamic behaviors to obtain the same benefits we observe.    